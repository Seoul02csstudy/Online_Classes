##### 1. HTTP 상태코드

- 1xx: 요청이 수신되어 처리중

- 2xx: 요청 정상 처리

- 3xx: 요청을 완료하려면 추가 행동이 필요

- 4xx: 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음

- 5xx: 서버오류, 서버가 정상 요청을 처리못함



##### 2. 일반 헤더

- HTTP 헤더: HTTP 전송에 필요한ㄴ 모든 부가정보(메시지 바디의 내용, 크기, 압축, 인증 등등)



##### 3. 콘텐츠 네고시에이션

- 클라이언트가 선호하는 표현 요청



##### 4. 쿠키

- 웹브라우저에는 쿠키 저장소가 있다.

- 서버는 로그인에 성공하면 쿠키 저장소에 유저 정보를 저장할 수 있도록 한다.

- 이후, 웹브라우저는 항상 쿠키의 유저 정보를 보낸다.

- 하지만, 보안문제가 존재한다. -> secure, httponly, samesite등 보안 방법 존재

- 쿠키 저장할때 유효기간 설정 가능(시간제한, 브라우저종료)



##### 5. 캐시

- 웹브라우저에는 브라우저 캐시 저장소가 있다.

- 서버에서 데이터를 던져주면 캐시 저장소로 간다. 클라이언트는 재요청을 할때는 저장소먼저 확인하고 서버에 요청한다.

- 그 결과, 더 빠르게 사용 가능하고 비용절감 가능



##### 6. 검증 헤더와 조건부 요청

- 위에 내용에 이어서 재요청을 했는데 데이터 변경이 없으면, 또 똑같은걸 재용청 하는게 아깝다.

- 그래서 데이터가 마지막에 수정된 시간이 동일하다면, 서버는 '변경없음' 응답만 전송하고 클라이언트는 저장소에서 유효가 만료된 데이터를 다시 갱신



##### 7. 검증 헤더와 조건부 요청2

- 위의 단점. 1초 미만 단위로 캐시 조정이 불가능

- 날짜 기반의 로직 사용

- 데이터를 수정해서 날짜가 다르지만 수정 결과가 동일한 경우 또 보냄.

- 해결책: ETag-> 캐시용 데이터에 임의의 고유한 버전 이름을 붙이고 데이터가 변경되면 이름을 바꾸어서 변경함(해시) 즉, 날짜 계산이고 뭐고 그냥 이름 다르면 변경

- 그 결과, 캐시 제어 로직을 서버에서 완전히 관리



##### 8. 캐시와 조건부 요청 헤더

- 캐시 컨트롤: 캐시 조작하는 캐시 지시어.(캐시저장, 유효시간, 검증)

- 원 서버: 진짜 데이터를 던져주는 서버(origin server)

- 원 서버에 요청하면 오래 걸림 -> 그래서 중간에 중개 서버(?)를 만듦. 이를 프록시 캐시 서버라고 한다.



##### 9. 캐시 무효화

- 확실한 캐시 무효화 응답: 확실하게 캐시를 무시하는 방법

- no-cache, no-store, must-revalidate, pargma: no-cache

- 